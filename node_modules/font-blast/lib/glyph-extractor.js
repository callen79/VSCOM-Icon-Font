"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svgo = require("svgo");

var _svgo2 = _interopRequireDefault(_svgo);

var _xmldom = require("xmldom");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var svgo = new _svgo2.default({});

/**
 * Optimizes the SVG text and compresses the data 'path' for all lines
 * @param svgText Original SVG content
 * @reutrn string New SVG content
 */
var optimizeSvgText = function optimizeSvgText(svgText) {
  return new Promise(function (resolve, reject) {
    svgo.optimize(svgText, function (result) {
      resolve(result.data);
    });
  });
};

/**
 * Callback recieves an array of characters with the format of
 * {
 * code: 'unicode',
 * name: 'special name, if provided',
 * ref: name or code
 * svg:  'full svg content required to render'
 * path: 'just the path from the svg content'
 * }
 *
 * @param fontSvgText SVG font definition containing all characters
 * @param charNameMap
 * @param callback
 * @param processCharInfoFn A function that provides the character filename
 * Array<IconInformation>
 */
function extractCharsFromFont(fontSvgText, charNameMap, callbackFn, processCharInfoFn) {
  var doc = new _xmldom.DOMParser().parseFromString(fontSvgText, "text/xml").documentElement;
  var fontSpec = doc.getElementsByTagName("font")[0];
  var defaultCharWidth = fontSpec.getAttribute("horiz-adv-x");
  var fontFace = doc.getElementsByTagName("font-face")[0];
  var defaultCharHeight = fontFace.getAttribute("units-per-em");
  var defaultCharAscent = fontFace.getAttribute("ascent");
  var glyphs = doc.getElementsByTagName("glyph");

  //"square" fonts tend to be based at the center (like glyphicon)
  //white other fonts tend to be based around the charAscent mark
  //so when need to flip them with different adjustments
  //(defaultCharWidth == defaultCharHeight ? defaultCharHeight : defaultCharAscent),
  var translateOffset = defaultCharAscent;
  var charMap = charNameMap || {};
  var cleanCharacter = processCharInfoFn || function (char) {
    return char;
  };

  var dataOnGlyphs = [];
  for (var i = 0; i < glyphs.length; i++) {
    var glyph = glyphs[i];
    //some strange fonts put empty glyphs in them
    if (!glyph) continue;
    var iconCode = glyph.getAttribute("unicode");
    var pathData = glyph.getAttribute("d");
    var customWidthMatch = glyph.getAttribute("horiz-adv-x");
    var contentWidth = customWidthMatch ? customWidthMatch : defaultCharWidth;

    //some glyphs matched without a unicode value so we should ignore them
    if (!iconCode) continue;

    if (iconCode.indexOf("&#") !== -1) {
      iconCode = iconCode.replace("&#x", "");
    }

    if (iconCode.length === 1) {
      iconCode = iconCode.charCodeAt(0).toString(16);
    }

    //Skip empty-looking glyphs
    if (!iconCode.length || !pathData || pathData.length < 10) continue;

    var useCharacterName = charMap[iconCode] || glyph.getAttribute("glyph-name") || iconCode;

    var charInfo = {
      code: iconCode,
      name: useCharacterName,
      ref: useCharacterName || iconCode,
      path: pathData,
      svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 " + contentWidth + " " + defaultCharHeight + "\">\n        <g transform=\"scale(1,-1) translate(0 -" + translateOffset + ")\">\n            <path d=\"" + pathData + "\"/>\n        </g></svg>"
    };
    dataOnGlyphs = dataOnGlyphs.concat(charInfo);
  }

  var cleanAllPromises = dataOnGlyphs.map(function (charInfo) {
    return optimizeSvgText(charInfo.svg).then(function (cleanSvg) {
      var newInfo = Object.assign({}, charInfo, {
        svg: cleanSvg,
        path: cleanSvg.match(/d="(.*?)"/)[1]
      });
      if (cleanCharacter) newInfo = cleanCharacter(newInfo);
      return newInfo;
    });
  });

  var promise = Promise.all(cleanAllPromises);
  if (callbackFn) {
    promise = promise.then(callbackFn);
  }
  return promise;
}

exports.default = extractCharsFromFont;
module.exports = exports["default"];